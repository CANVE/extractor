< definition from source file: /repos/canve/extractor/compiler-plugin-unit-test-lib/src/main/scala/injectable/injectableCompiler.scala >

class InjectingCompiler(settings: scala.tools.nsc.Settings, 
                       reporter: scala.tools.nsc.reporters.Reporter,
                       injectable: Injectable) extends scala.tools.nsc.Global(settings, reporter) {

  def compileCodeSnippet(code: String): InjectingCompiler = compileSourceFiles(writeCodeSnippetToTempFile(code))

  private def compileSourceFiles(files: File*): InjectingCompiler = {
    val command = new scala.tools.nsc.CompilerCommand(files.map(_.getAbsolutePath).toList, settings)
    new Run().compile(command.files)
    this
  }

  private def writeCodeSnippetToTempFile(code: String): File = {
    val file = File.createTempFile("canve-compiler-plugin-unit-test-tmp", ".scala")
    IOUtils.writeToFile(file, code)
    file.deleteOnExit()
    file
  }
  
  private def compileSourceResources(urls: URL*): InjectingCompiler = {
    compileSourceFiles(urls.map(_.getFile).map(new File(_)): _*)
  }

  /*
   * a standard PluginComponent, which executes the component supplied
   * to it, after the typical compiler plugin ceremony
   */
  private class Plugin(val global: Global) extends PluginComponent {

    val runsAfter = List("typer")

    override val runsRightAfter = Some("typer")
  
    val phaseName = "canve-unit-tester"
    
    
    override def newPhase(prev: Phase): Phase = new Phase(prev) {
      def name : String = phaseName 
      override def run() {
        
        println(Console.BLUE + Console.BOLD + "\ncanve unit test running" + Console.RESET)
        
        def units = global.currentRun
                    .units
                    .toSeq
                    .sortBy(_.source.content.mkString.hashCode())
        
        units.foreach { unit =>
          injectable.apply(global)(unit.body)
          println(Console.BLUE + "canve unit testing plugin examining source file" + unit.source.path + "..." + Console.RESET)
        }
      }
    }
  }

  /*
   * an override to the canonical compilation sequence:
   * it invokes all standard compiler phases up to the typer phase,
   * after which point the supplied compiler plugin is invoked, and no more.  
   */
  override def computeInternalPhases() {
    val phs = List(
      syntaxAnalyzer -> "parse source into ASTs, perform simple desugaring",
      analyzer.namerFactory -> "resolve names, attach symbols to named trees",
      analyzer.packageObjects -> "load package objects",
      analyzer.typerFactory -> "the meat and potatoes: type the trees",
      new Plugin(this) -> "the plugin injector"
    )
    phs foreach (addToPhasesSet _).tupled
  }
}
